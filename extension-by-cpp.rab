= Improve extension API

: subtitle
   C++ as better language for extension
: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2017
: date
   2017-09-19
: allotted-time
   35m
: theme
   .

= Ad1: I'm distributing shocker combatmen to Rabbit users\n(('tag:x-small:å®£ä¼1ï¼šRabbitãƒ¦ãƒ¼ã‚¶ãƒ¼ã«'))\n(('tag:x-small:ã‚·ãƒ§ãƒƒã‚«ãƒ¼æˆ¦é—˜å“¡ã‚’é…å¸ƒä¸­'))

  # img
  # src = images/shocker.jpeg
  # relative_height = 110
  # reflect_ratio = 0.1
  # relative_margin_top = -2

== Slide properties

: enable-title-on-image
   true

= Ad2: Silver sponsor

  # img
  # src = images/clear-code-silver-sponsor.png
  # relative_height = 100
  # reflect_ratio = 0.1

== Slide properties

: enable-title-on-image
   false

= Ad3: Red Data Tools

  * Project that provides data processing tools for Ruby\n
    (('note:Rubyç”¨ã®ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ„ãƒ¼ãƒ«ç¾¤ã‚’æä¾›ã™ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ'))
    * https://red-data-tools.github.io/
  * Workshop during the afternoon break on the 2nd day (today!)\n
    (('note:2æ—¥ç›®ï¼ˆä»Šæ—¥ï¼ï¼‰ã®åˆå¾Œä¼‘æ†©ä¸­ã«ãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ãŒã‚ã‚‹ã‚ˆï¼'))

= Ad4: OSS Gate

  * Project that increases people who join OSS development\n
    (('note:OSSã®é–‹ç™ºã«ç¶™ç¶šçš„ã«å‚åŠ ã™ã‚‹äººã‚’ç¶™ç¶šçš„ã«å¢—ã‚„ã™å–ã‚Šçµ„ã¿'))
    * https://oss-gate.github.io/

= Ad4: OSS Gate

  * Ruby is OSS\n
    (('note:Rubyã‚‚OSS'))
    * OSS Gate wants to increase people to join Ruby itself and RubyGems development!\n
      (('note:OSS Gateã§ã¯Rubyæœ¬ä½“ã®é–‹ç™ºã‚„å„ç¨®RubyGemã®é–‹ç™ºã«å‚åŠ ã™ã‚‹äººã‚‚å¢—ã‚„ã—ãŸã„ï¼'))

= Ad4: OSS Gate

  * Now, in Tokyo, Sapporo, Osaka and Kyoto\n
    (('note:ç¾åœ¨ã¯æ±äº¬ãƒ»æœ­å¹Œãƒ»å¤§é˜ªãƒ»äº¬éƒ½ã§æ´»å‹•ä¸­'))
    * If you live near by, join "OSS Gate workshop"!\n
      (('note:ã“ã‚Œã‚‰ã®åœ°åŸŸã«ä½ã‚“ã§ã„ã‚‹äººã¯ã€ŒOSS Gateãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ã€ã«å‚åŠ ã—ã‚ˆã†ï¼'))

= Ad4: OSS Gate

  * Want to expand to Hiroshima and other areas all over the world!\n
    (('note:åºƒå³¶ã‚„ä¸–ç•Œä¸­ã®ã„ã‚ã‚“ãªåœ°åŸŸã§æ´»å‹•ã—ãŸã„ï¼'))
    * If you're interested in increasing people who join OSS development, talk to me!\n
      (('note:OSSã®é–‹ç™ºã«å‚åŠ ã™ã‚‹äººãŒå¢—ãˆã‚‹ã“ã¨ã«èˆˆå‘³ã®ã‚ã‚‹äººã¯ç§ã«å£°ã‚’ã‹ã‘ã¦ï¼'))

= What I want to do\n(('note:ã‚„ã‚ŠãŸã„ã“ã¨'))

(('tag:center'))
Improve performance\n
with C/C++ libraries\n
(('note:C/C++ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ä½¿ã£ãŸé«˜é€ŸåŒ–'))

  * Not create binding\n
    (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½œã‚ŠãŸã„ã‚ã‘ã˜ã‚ƒãªã„'))

= Point of improving perf\n(('note:é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã«å¤§äº‹ãªã“ã¨'))

(('tag:center'))
Done in C/C++\n
as much as possible\n
(('note:ã§ãã‚‹ã ã‘C/C++å†…ã§å®Œçµã•ã›ã‚‹'))

  * Don't move between\n
    C/C++ and Ruby\n
    (('note:C/C++ã¨Rubyé–“ã§ã„ã£ãŸã‚ŠããŸã‚Šã—ãªã„'))

= Example: #sum\n(('note:ä¾‹ï¼š#sum'))

  # coderay ruby

  numbers = (1..100000).to_a
  # Move between C and Ruby: 25.1ms
  numbers.inject(&:+)
  # Done in C:                0.5ms
  # 50x fasterï¼ˆ50å€é€Ÿã„ï¼‰
  numbers.sum

= FYI: #inject(symbol)\n(('note:å‚è€ƒæƒ…å ±ï¼š#inject(symbol)'))

  # coderay ruby

  numbers = (1..100000).to_a
  # Move between C and Ruby: 25.1ms
  numbers.inject(&:+)
  # Done in C:                0.5ms
  # 50x fasterï¼ˆ50å€é€Ÿã„ï¼‰
  numbers.inject(:+)

= Extension and binding\n(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã¨ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°'))

  * Extension(('note:ï¼ˆæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰'))
    * Ruby library implemented in C\n
      (('note:Cã§å®Ÿè£…ã•ã‚ŒãŸRubyã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼'))
  * Binding(('note:ï¼ˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ï¼‰'))
    * Ruby library to use library implemented in other languages\n
      (('note:ä»–è¨€èªå®Ÿè£…ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ãŸã‚ã®Rubyã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒª'))

= Binding usage\n(('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ä½¿ã„æ–¹'))

  * Export each API to Ruby\n
    (('note:ãã‚Œãã‚Œã®APIã‚’Rubyã§ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹'))
  * Combine exported APIs in Ruby\n
    (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒæä¾›ã™ã‚‹APIã‚’Rubyãƒ¬ãƒ™ãƒ«ã§çµ„ã¿åˆã‚ã›ã‚‹'))

= Binding usage example\n(('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ä½¿ã„æ–¹ä¾‹'))

  # coderay ruby

  require "cairo"
  include Cairo
  # Combine APIs
  s = PDFSurface.new("red.pdf", 10, 10) # API
  context = Context.new(s)              # API
  context.set_source_color(:red)        # API
  context.paint                         # API
  context.show_page                     # API
  s.finish                              # API

= Point of improving perf\n(('note:é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã«å¤§äº‹ãªã“ã¨'))

(('tag:center'))
Done in C/C++\n
as much as possible\n
(('note:ã§ãã‚‹ã ã‘C/C++å†…ã§å®Œçµã•ã›ã‚‹'))

  * Don't move between\n
    C/C++ and Ruby\n
    (('note:C/C++ã¨Rubyé–“ã§ã„ã£ãŸã‚ŠããŸã‚Šã—ãªã„'))

= Perf improvement example\n(('note:é«˜é€ŸåŒ–ä¾‹'))

  # coderay ruby

  # Don't combine APIs in Ruby
  # Rubyãƒ¬ãƒ™ãƒ«ã§APIã‚’çµ„ã¿åˆã‚ã›ãªã„
  ## context.set_source_color(:red) # API
  ## context.paint                  # API
  ## context.show_page              # API
  # Just call higher level API in Ruby
  # Rubyã‹ã‚‰ã¯ã‚‚ã£ã¨é«˜ãƒ¬ãƒ™ãƒ«ãªAPIã‚’å‘¼ã³å‡ºã™
  context.show_red_page # Implemented in C
                        # ã“ã“ã¯Cã§å®Ÿè£…

= What I want to do\n(('note:ã‚„ã‚ŠãŸã„ã“ã¨'))

(('tag:center'))
Improve performance\n
with C/C++ libraries\n
(('note:C/C++ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ä½¿ã£ãŸé«˜é€ŸåŒ–'))

  * Not create binding\n
    (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½œã‚ŠãŸã„ã‚ã‘ã˜ã‚ƒãªã„'))

= Use case\n(('note:é«˜é€ŸåŒ–ã—ãŸã„å ´é¢'))

  * Machine learning\n
    (('note:æ©Ÿæ¢°å­¦ç¿’'))
    * Combine array/matrix operations\n
      (('note:é…åˆ—ãƒ»è¡Œåˆ—ã«å¯¾ã™ã‚‹æ¼”ç®—ã‚’ã¾ã¨ã‚ã‚‹'))

= Raw C API for extension\n(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ç”¨ã®ç”Ÿã®C API'))

(('tag:center'))
Not bad but can be verbose because of C\n
(('note:æ‚ªããªã„ã‚“ã ã‘ã©Cãªã®ã§å†—é•·'))

  * Need better approach\n
    (('note:ã‚‚ã£ã¨ã„ã„æ„Ÿã˜ã®æ–¹æ³•ã‚’ä½¿ã„ãŸã„'))

= Requirements\n(('note:è¦ä»¶'))

  * Easy to use C/C++ libraries\n
    (('note:C/C++ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ç°¡å˜ã«ä½¿ãˆã‚‹ã“ã¨'))
  * Easy to write (('note:as much as possible'))\n
    (('note:ã§ãã‚‹ã ã‘æ›¸ãã‚„ã™ã„ã“ã¨'))
  * Easy to debug (('note:as much as possible'))\n
    (('note:ã§ãã‚‹ã ã‘ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„ã“ã¨'))

= Approaches(('note:ï¼ˆå®Ÿç¾æ–¹æ³•ï¼‰'))

  * Extend language to support writing extension\n
    (('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«è¨€èªã‚’æ‹¡å¼µ'))
  * Not based on C\n
    (('note:Cä»¥å¤–ã®è¨€èªã‚’ä½¿ã†'))
  * Provide convenient API\n
    (('note:ä¾¿åˆ©APIã‚’æä¾›'))

= Recommended approach\n(('note:ã‚ªã‚¹ã‚¹ãƒ¡ã®å®Ÿç¾æ–¹æ³•'))

  * Extend language to support writing extension\n
    (('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«è¨€èªã‚’æ‹¡å¼µ'))
  * Not based on C\n
    (('note:Cä»¥å¤–ã®è¨€èªã‚’ä½¿ã†'))
  * ((*Provide convenient API*))\n
    (('note:ä¾¿åˆ©APIã‚’æä¾›'))

= Provide convenient API\n(('note:ä¾¿åˆ©ãªAPIã‚’æä¾›'))

  * Rice: ((*C++*)) + Ruby
  * Ext++: ((*C++*))11 + Ruby
  * Boost.Python: ((*C++*)) + Python
  * pybind11: ((*C++*))11 + Python

= Useful C++ properties\n(('note:C++ã®ä¾¿åˆ©ã®æ€§è³ª'))

  * C++ can use C API directory\n
    (('note:C++ã§ã¯Cã®APIã‚’ç›´æ¥ä½¿ãˆã‚‹'))
    * No wrapper API or libffi\n
      (('note:ãƒ©ãƒƒãƒ‘ãƒ¼APIã‚‚libffiã‚‚ã„ã‚‰ãªã„'))
  * C++((*11 or later*)) has many convenient features\n
    (('note:C++11ä»¥é™ã«ã¯ä¾¿åˆ©æ©Ÿèƒ½ãŒãŸãã•ã‚“ã‚ã‚‹'))

= C++ convenient feature1\n(('note:C++ã®ä¾¿åˆ©æ©Ÿèƒ½1'))

(('tag:center'))
Type detection with "auto"\n
(('note:autoã§å‹æ¨è«–ï¼ˆC++11ï¼‰'))

  # coderay cpp

  int n = 10;
  auto square = n * n;
  // square's type is "int"
  // squareã®å‹ã¯ã€Œintã€

= C++ convenient feature2\n(('note:C++ã®ä¾¿åˆ©æ©Ÿèƒ½2'))

(('tag:center'))
Lambda expression (C++11)\n
(('note:ãƒ©ãƒ ãƒ€å¼ï¼ˆC++11ï¼‰'))

  # coderay cpp

  // In Ruby: ->(n) {n * n}
  auto square = [](int n) {
    return n * n; // Return type is detected
  };
  square(10); // => 100

= C++ convenient feature3\n(('note:C++ã®ä¾¿åˆ©æ©Ÿèƒ½3'))

(('tag:center'))
Default argument\n
(('note:ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°'))

  # coderay cpp

  // In Ruby: def square(n=10)
  int square(int n=10) {
    return n * n;
  }
  // square() == square(10)

= Convenient API example1\n(('note:ä¾¿åˆ©ãªAPIä¾‹1'))

  # coderay ruby

  # Ruby: Normal
  class Sample
    def hello
      "Hello"
    end
  end

= Convenient API example1\n(('note:ä¾¿åˆ©ãªAPIä¾‹1'))

  # coderay ruby

  # Ruby: No syntax sugar
  Sample = Class.new do
    define_method(:hello) do
      "Hello"
    end
  end

= Convenient API example1\n(('note:ä¾¿åˆ©ãªAPIä¾‹1'))

  # coderay cpp

  // C++: Ext++
  #include <ruby.hpp>
  extern "C" void Init_sample(void) {
    // Parent class (rb_cObject) is omittable
    rb::Class("Sample"). // class Sample in Ruby
      define_method("hello", // def hello in Ruby
        [](VALUE self) { // ->() {"Hello"} in Ruby
          return rb_str_new_static("Hello");
        });
  }

= Convenient API example1\n(('note:ä¾¿åˆ©ãªAPIä¾‹1'))

  # coderay c

  /* C */
  #include <ruby.h>
  static VALUE rb_sample_hello(VALUE self) {
    return rb_str_new_static("Hello");
  } /* â†‘Definition. */
  void Init_sample(void) {
    /* â†“Must specify parent class. */
    VALUE sample = rb_define_class("Sample", rb_cObject);
    /* â†“Registration. They are separated. */
    rb_define_method(sample, "hello", rb_sample_hello, 0);
  }

= C++ convenient feature4\n(('note:C++ã®ä¾¿åˆ©æ©Ÿèƒ½4'))

(('tag:center'))
Custom type conversion\n
(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  * "Cast" is customizable\n
    (('note:ã€Œã‚­ãƒ£ã‚¹ãƒˆã€ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ã¨ã„ã†ã“ã¨'))

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  // Wrapper class of VALUE
  class Object {
  public:
    // def initialize(rb_object)
    //   @rb_object_ = rb_object
    // end
    Object(VALUE rb_object) : rb_object_(rb_object) {}
  private:
    VALUE rb_object_;
  };

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  class Object {
    operator bool() const {
      return RTEST(rb_object_);
    }
  };
  // Object nil(Qnil); // Qnil wrapper
  // if (nil) { â†’ if (RTEST(Qnil)) {

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  // Trap1ï¼ˆç½ 1ï¼‰
  // boolâ†’int cast is available
  // Implicit Objectâ†’boolâ†’ int cast
  // boolâ†’intã®ã‚­ãƒ£ã‚¹ãƒˆãŒã§ãã‚‹ã®ã§
  // æš—é»™çš„ã«Objectâ†’boolâ†’intã¨ã‚­ãƒ£ã‚¹ãƒˆ
  Object(Qture) + 1; // â†’ RTEST(Qtrue) + 1
                     // â†’ 1 + 1
                     // â†’ 2

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  class Object {
    // Deny explicit cast (C++11)
    // æš—é»™ã®ã‚­ãƒ£ã‚¹ãƒˆã‚’ç¦æ­¢ï¼ˆC++11ï¼‰
    explicit operator bool() const {
      return RTEST(rb_object_);
    }
  };
  // Object(Qtrue) + 1; // â†’ Compile error

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  // Trap2ï¼ˆç½ 2ï¼‰
  class Object {
  public:
    // Used as implicit VALUEâ†’Object cast
    // æš—é»™ã®VALUEâ†’Objectã‚­ãƒ£ã‚¹ãƒˆã«ä½¿ã‚ã‚Œã‚‹
    Object(VALUE rb_object);
  };

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  // Trap2ï¼ˆç½ 2ï¼‰
  // VALUE is just a numberï¼ˆVALUEã¯ãŸã ã®æ•°å€¤ï¼‰
  typedef unsigned long VALUE;
  Object identify(Object x) {return x;}
  // Implicit VALUEâ†’Object cast
  // æš—é»™çš„ã«VALUEâ†’Objectã¨ã‚­ãƒ£ã‚¹ãƒˆ
  identify(100); // == identify(Object(100));

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  class Object {
    // Deny explicit cast
    // æš—é»™ã®ã‚­ãƒ£ã‚¹ãƒˆã‚’ç¦æ­¢
    explicit Object(VALUE rb_object);
  };
  // identify(100); // â†’ Compile error

= Custom type conversion\n(('note:å‹å¤‰æ›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º'))

  # coderay cpp

  class Object {
    operator VALUE() const {return rb_object_;}
  };
  // Convenientï¼ˆä¾¿åˆ©ï¼‰
  rb_p(Object(Qnil)); // â†’ rb_p(Qnil);
  // Not compile error. Hmm...
  Object(Qnil) + 1;   // â†’ Qnil + 1;
                      // â†’ 8 + 1;
                      // â†’ 9;

= C++ convenient feature5\n(('note:C++ã®ä¾¿åˆ©æ©Ÿèƒ½5'))

(('tag:center'))
Template and specialization\n
(('note:ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨ç‰¹æ®ŠåŒ–'))

  * ğŸ‘Consistent cast API\n
    (('note:ä¸€è²«æ€§ã®ã‚ã‚‹ã‚­ãƒ£ã‚¹ãƒˆAPIã«ä½¿ãˆã‚‹'))

= Consistent cast API\n(('note:ä¸€è²«æ€§ã®ã‚ã‚‹ã‚­ãƒ£ã‚¹ãƒˆAPI'))

  # coderay cpp

  namespace rb {
    // Consistent cast API
    // Example: rb::cast<int32_t>(Object(NUM2INT(10));
    // Example: rb::cast<Object>(10);
    // FYI: C++ cast syntax: static_cast<TYPE>(expression)
    template <typename RETURN_TYPE,
              typename ARGUMENT_TYPE>
    inline RETURN_TYPE cast(ARGUMENT_TYPE object);
  }

= Consistent cast API\n(('note:ä¸€è²«æ€§ã®ã‚ã‚‹ã‚­ãƒ£ã‚¹ãƒˆAPI'))

  # coderay cpp

  template <> // rb::cast<int32_t>(Object(NUM2INT(10));
  inline int32_t cast<int32_t, Object>(Object rb_object) {
    return NUM2INT(rb_object);
  }
  template <> // rb::cast<Object>(10);
  inline Object cast<Object, int32_t>(int32_t n) {
    return Object(INT2NUM(n));
  }

= Consistent cast API\n(('note:ä¸€è²«æ€§ã®ã‚ã‚‹ã‚­ãƒ£ã‚¹ãƒˆAPI'))

  # coderay cpp

  // rb::cast<const char *>(Object(rb_str_new_cstr("X"));
  template <> inline
  const char *cast<const char *, Object>(Object rb_object) {
    VALUE rb_object_raw = rb_object;
    return StringValueCStr(rb_object_raw);
  }
  template <> inline // rb::cast<Object>("hello");
  Object cast<Object, const char *>(const char *c_string) {
    return Object(rb_str_new_cstr(c_string));
  }

= C++ convenient feature6\n(('note:C++ã®ä¾¿åˆ©æ©Ÿèƒ½6'))

(('tag:center'))
Initializer list (C++11)\n
(('note:åˆæœŸåŒ–ãƒªã‚¹ãƒˆï¼ˆC++11ï¼‰'))

  * "{A,B,...}" is customizable\n
    (('note:ã€Œ{A, B, ...}ã€ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹'))

= Initializer list\n(('note:åˆæœŸåŒ–ãƒªã‚¹ãƒˆ'))

  # coderay cpp

  Object Object::send(
    ID name_id,
    std::initializer_list<VALUE> args);
  // Ruby: "hello".send(:tr, "e", "E")
  Object(rb_str_new_cstr("hello")).
    send(rb_intern("tr"),
         {rb_str_new_cstr("e"),
          rb_str_new_cstr("E")});

= Initializer list\n(('note:åˆæœŸåŒ–ãƒªã‚¹ãƒˆ'))

  # coderay cpp

  Object Object::send(
    ID name_id,
    std::initializer_list<VALUE> args,
    VALUE (*block)(VALUE data));
  // Ruby: array.send(:collect) {true}
  Object(array).
    send(rb_intern("collect"),
         {}, // Clear API than variable arguments
         [](VALUE data) {return Qtrue;});

= Convenient API example2\n(('note:ä¾¿åˆ©ãªAPIä¾‹2'))

  # coderay cpp

  // C++: Ext++
  rb::Object(rb_n).
    send("step",
         // Implicit Objectâ†’VALUE cast
         {rb::cast<rb::Object>(10)},
         [](VALUE i) {return rb_p(i)});
  // n.step(10) {|i| p i}

= Convenient API example3\n(('note:ä¾¿åˆ©ãªAPIä¾‹3'))

  # coderay cpp

  // C++: Rice
  #include <rice/Class.hpp>
  static const char * // Not VALUE! (Auto convert)
  rb_sample_hello(Rice::Object self) {
    return "Hello";
  }
  extern "C" void Init_sample() {
    Rice::define_class("Sample").
      define_method("hello", &rb_sample_hello);
  }

= C++ based API: Pros1\n(('note:C++ãƒ™ãƒ¼ã‚¹ã®APIï¼šé•·æ‰€1'))

(('tag:center'))
Easier to write than C\n
(('note:Cã‚ˆã‚Šæ›¸ãã‚„ã™ã„'))

  * Require C++11 or later\n
    (('note:C++11ä»¥é™ãªã‚‰'))

= C++ based API: Pros2\n(('note:C++ãƒ™ãƒ¼ã‚¹ã®APIï¼šé•·æ‰€2'))

(('tag:center'))
Easy to use for C API users\n
(('note:æ—¢å­˜ã®C APIã‚’ä½¿ã£ã¦ã„ã‚‹äººãªã‚‰ä½¿ã„ã‚„ã™ã„'))

  * Use C directly incl macro\n
    (('note:ãƒã‚¯ãƒ­ã‚‚å«ã‚ã¦Cã®æ©Ÿèƒ½ã‚’ç›´æ¥ä½¿ãˆã‚‹'))
  * Don't need to migrate to all convenient API at once\n
    (('note:ä¸€æ°—ã«æ›¸ãæ›ãˆã‚‹ã®ã§ã¯ãªãå¾ã€…ã«ç§»è¡Œã§ãã‚‹'))

= C++ based API: Pros3\n(('note:C++ãƒ™ãƒ¼ã‚¹ã®APIï¼šé•·æ‰€3'))

(('tag:center'))
Easy to debug for C API users\n
(('note:æ—¢å­˜ã®C APIã‚’ä½¿ã£ã¦ã„ã‚‹äººãªã‚‰ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„'))

  * Can use GDB/LLDB directly\n
    (('note:GDB/LLDBã‚’ç›´æ¥ä½¿ãˆã‚‹'))
    * GDB/LLDB have built-in C++ support\n
      (('note:GDB/LLDBã¯çµ„ã¿è¾¼ã¿ã§C++ã‚’ã‚µãƒãƒ¼ãƒˆ'))

= C++ based API: Pros4\n(('note:C++ãƒ™ãƒ¼ã‚¹ã®APIï¼šé•·æ‰€4'))

(('tag:center'))
Easy to optimize\n
(('note:æœ€é©åŒ–ã—ã‚„ã™ã„'))

  * [Feature #13434] better method definition in C API\n
    (('note:Cã®ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©APIã®æ”¹è‰¯'))

= Better method definition\n(('note:ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã®æ”¹è‰¯'))

  * Metadata for optimization\n
    (('note:æœ€é©åŒ–ã®ãŸã‚ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä»˜ä¸'))
    * e.g.: Reduce memory allocations\n
      (('note:ä¾‹ï¼šãƒ¡ãƒ¢ãƒªãƒ¼ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ¸›ã‚‰ã™'))
  * Lazy method definition\n
    (('note:å¿…è¦ã«ãªã‚‹ã¾ã§ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã‚’é…ã‚‰ã›ã‚‹'))
    * e.g.: Reduce start-up time\n
      (('note:ä¾‹ï¼šèµ·å‹•æ™‚é–“ã®é«˜é€ŸåŒ–'))

= Argument metadata\n(('note:å¼•æ•°ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿'))

  # coderay ruby

  class Hello
    # Default argument is just for
    # example. Other metadata will
    # be more useful for optimization.
    def hello(name, message="world")
    end
  end

= Argument metadata\n(('note:å¼•æ•°ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿'))

  # coderay cpp

  // C++: Rice
  cHello.
    define_method(
      "hello",
      &hello,
      (Rice::Arg("name"), // â†“Default
       Rice::Arg("message")="world"));

= Lazy method definition\n(('note:é…å»¶ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # coderay ruby

  class X
    def a; end # Not define yet
    def b; end # Not define yet
  end
  x = X.new
  x.a # Define #a and #b

= Lazy method definition\n(('note:é…å»¶ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # coderay c

  /* One of new C API ideas */
  struct rb_method_entries entries[] = {
    "a", ...,
    "b", ...,
  };
  /* The definitions aren't defined at once. */
  /* They are defined when the next method call. */
  rb_define_method_with_table(rb_cX, entries);

= Lazy method definition\n(('note:é…å»¶ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # coderay c

  // C++ implementation sample
  {
    rb::Class("X").
      // Don't call rb_define_method() yet.
      define_method("a", ...).
      // Don't call rb_define_method() yet.
      define_method("b", ...);
    // Destructor is called.
    // Call rb_define_method_with_table()
    // in destructor.
  }

= Lazy method definition\n(('note:é…å»¶ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # coderay c

  // Ext++ implementation is just for test
  rb::Class("X").
    // Call rb_define_method() immediately.
    define_method("a", ...).
    // Don't call rb_define_method() in
    // the following define_method()s.
    enable_lazy_define_method().
    // Don't call rb_define_method() yet.
    define_method("b", ...);

= Lazy method definition\n(('note:é…å»¶ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # coderay ruby

  # Define only benchmark code in Ruby.
  # Benchmark target code is in C++.
  n = 10000
  Bench = Class.new do
    n.times do |i|
      define_method("method#{i}") do
      end
    end
  end

= Lazy method definition\n(('note:é…å»¶ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # coderay ruby

  # Call benchmark code in Ruby.
  # Benchmark target code is in C++.
  n = 10000
  bench = Bench.new
  n.times do |i|
    bench.__send__("method#{i}")
  end

= Lazy method definition\n(('note:é…å»¶ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # RT

  Type, Define only, Called

  Normal, 5ms, 5ms
  Lazy,   1ms, 5ms

(('tag:center'))
5x faster when any methods aren't called\n
(('note:ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œãªã‘ã‚Œã°5å€é€Ÿã„'))

= C++ based API: Cons1\n(('note:C++ãƒ™ãƒ¼ã‚¹ã®APIï¼šçŸ­æ‰€1'))

(('tag:center'))
C++ is difficult\n
(('note:C++ã¯é›£ã—ã„'))

  * e.g.: Template\n
    (('note:ãŸã¨ãˆã°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ'))
  * Easy to write unreadable code\n
    (('note:ç°¡å˜ã«ãƒªãƒ¼ãƒ€ãƒ–ãƒ«ã˜ã‚ƒãªã„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‘ã‚‹'))

= C++ based API: Cons2\n(('note:C++ãƒ™ãƒ¼ã‚¹ã®APIï¼šçŸ­æ‰€2'))

(('tag:center'))
Slower build\n
(('note:ãƒ“ãƒ«ãƒ‰ãŒé…ã„'))

  * It may reduce try&error cycle\n
    (('note:è©¦è¡ŒéŒ¯èª¤ã—ã«ãããªã‚‹ã‹ã‚‚'))

= C++ based API: Problem\n(('note:C++ãƒ™ãƒ¼ã‚¹ã®APIï¼šèª²é¡Œ'))

(('tag:center'))
Exception\n
(('note:ä¾‹å¤–'))

  * Ruby exception breaks C++ RAII (destructor)\n(('note:(Resource Acquisition Is Initialization)'))\n
    (('note:Rubyã®ä¾‹å¤–ç™ºç”Ÿâ†’C++ã®RAIIï¼ˆãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ï¼‰ãŒå‹•ã‹ãªã„'))
    * Because it uses setjmp/longjmp\n
      (('note:Rubyã®ä¾‹å¤–ã¯setjmp/longjmpã‚’ä½¿ã£ã¦ã„ã‚‹ã‹ã‚‰'))

= Exception: Solution\n(('note:ä¾‹å¤–ï¼šè§£æ±ºæ³•'))

  (1) Rescue Ruby exception\n
      (('note:Rubyã®ä¾‹å¤–ã‚’rescue'))
  (2) Throw C++ exception\n
      (('note:C++ã®ä¾‹å¤–ã«ã—ã¦throw'))
  (3) Re-raise the Ruby exception\n
      (('note:å®‰å…¨ãªå ´æ‰€ã§Rubyã®ä¾‹å¤–ã‚’å†raise'))

= Conclusion\n(('note:ã¾ã¨ã‚'))

  * C++ based API is useful\n
    (('note:C++ãƒ™ãƒ¼ã‚¹ã®APIã¯ä¾¿åˆ©'))
    * For writing ext uses C/C++ library\n
      (('note:C/C++ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ›¸ãã¨ã'))
    * For optimizing w/ easy to use API\n
      (('note:ä¾‹ï¼šä½¿ã„ã‚„ã™ã„APIã‚’ç¶­æŒã—ãŸã¾ã¾æœ€é©åŒ–ã™ã‚‹ã¨ã'))

== Slide properties

: image-slide-number-last-slide
   true

= Appendix\n(('note:ä»˜éŒ²'))

(('tag:center'))
Introduce easy to write extension approaches\n
(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ç°¡å˜ã«å®Ÿè£…ã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹'))

  * The following contents are used only when time is remained\n
    (('note:ä»¥é™ã®å†…å®¹ã¯æ™‚é–“ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã ã‘ä½¿ã†'))

= Approaches(('note:ï¼ˆå®Ÿç¾æ–¹æ³•ï¼‰'))

  * Extend language to support writing extension\n
    (('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’æ›¸ã‘ã‚‹ã‚ˆã†ã«è¨€èªã‚’æ‹¡å¼µ'))
  * Not based on C\n
    (('note:Cä»¥å¤–ã®è¨€èªã‚’ä½¿ã†'))
  * Provide convenient API\n
    (('note:ä¾¿åˆ©APIã‚’æä¾›'))

= Extend language\n(('note:è¨€èªã‚’æ‹¡å¼µ'))

  * Rubex: Extended Ruby\n
    (('note:Rubexï¼šRubyã‚’æ‹¡å¼µ'))
  * Cython: Extended Python\n
    (('note:Cythonï¼šPythonã‚’æ‹¡å¼µ'))

= How to run\n(('note:å‹•ã‹ã—æ–¹'))

  * Translate extension code to C\n
    (('note:æ‹¡å¼µè¨€èªã§æ›¸ã‹ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’Cã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«'))
  * Compile C code\n
    (('note:ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸCã‚³ãƒ¼ãƒ‰ã‚’ãƒ“ãƒ«ãƒ‰'))
  * Load the built extension\n
    (('note:ãƒ“ãƒ«ãƒ‰ã—ãŸæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’èª­ã¿è¾¼ã‚€'))

= Extended syntax\n(('note:æ‹¡å¼µã•ã‚ŒãŸæ§‹æ–‡'))

  * Type information\n
    (('note:å‹æƒ…å ±ã‚’æ›¸ã‘ã‚‹'))
  * C code snippet\n
    (('note:Cã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‘ã‚‹'))

= How to run: Rubex\n(('note:Rubexã®å‹•ã‹ã—æ–¹'))

  # coderay ruby
  # fibonacci.rubex
  class Fibonacci
    # "int" is type information
    def compute(int n)
      # ...
    end
  end

= How to run: Rubex\n(('note:Rubexã®å‹•ã‹ã—æ–¹'))

  # coderay console
  % rubex fibonacci.rubex
  % cd fibonacci
  % ruby extconf.rb
  % make

= How to run: Rubex\n(('note:Rubexã®å‹•ã‹ã—æ–¹'))

  # coderay ruby
  require_relative "fibonacci.so"
  p Fibonacci.new.compute(100)

= Extend language: Pros1\n(('note:æ‹¡å¼µè¨€èªï¼šé•·æ‰€1'))

(('tag:center'))
Friendly syntax for\n
base language users\n
(('note:ãƒ™ãƒ¼ã‚¹ã®è¨€èªã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯ãªã˜ã¿ã‚„ã™ã„æ§‹æ–‡'))

  * Most syntax is the same\n
    (('note:æ§‹æ–‡ã®å¤§éƒ¨åˆ†ã¯åŒã˜ã ã‹ã‚‰'))

= Extend language: Pros2\n(('note:æ‹¡å¼µè¨€èªï¼šé•·æ‰€2'))

(('tag:center'))
Easy to migrate from base lang\n
(('note:ãƒ™ãƒ¼ã‚¹ã®è¨€èªã‹ã‚‰ã®ç§»è¡ŒãŒå®¹æ˜“'))

  * Because upward compatibility\n
    (('note:ä¸Šä½äº’æ›ã ã‹ã‚‰'))
  * Code for base language works without modification\n
    (('note:ãƒ™ãƒ¼ã‚¹ã®è¨€èªã§æ›¸ã‹ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯å¤‰æ›´ãªã—ã§å‹•ã'))

= Extend language: Pros3\n(('note:æ‹¡å¼µè¨€èªï¼šé•·æ‰€3'))

(('tag:center'))
Doesn't require much C knowledge\n
(('note:ãã‚“ãªã«Cã®çŸ¥è­˜ã¯å¿…è¦ãªã„'))

  * Most code can be written with base language knowledge\n
    (('note:ã‚³ãƒ¼ãƒ‰ã®å¤§éƒ¨åˆ†ã¯ãƒ™ãƒ¼ã‚¹ã®è¨€èªã®çŸ¥è­˜ã§æ›¸ã‘ã‚‹'))

= Extend language: Cons1\n(('note:æ‹¡å¼µè¨€èªï¼šçŸ­æ‰€1'))

(('tag:center'))
You realize that it's not friendly syntax when you use it\n
(('note:ä½¿ã†ã¨ãã‚“ãªã«ãªã˜ã¿ã‚„ã™ã„æ–‡æ³•ã§ã¯ãªã„ã¨æ°—ã¥ã'))

  * Small differences will confuse you\n
    (('note:å°ã•ãªé•ã„ãŒã„ã‚ã„ã‚ã‚ã£ã¦ã‚ã‹ã‚Šã«ãã„'))

= Extend language: Cons2\n(('note:æ‹¡å¼µè¨€èªï¼šçŸ­æ‰€2'))

(('tag:center'))
Difficult to debug\n
(('note:ãƒ‡ãƒãƒƒã‚°ãŒé›£ã—ã„'))

  * Need base language, extend language and C knowledge\n
    (('note:ãƒ™ãƒ¼ã‚¹ã®è¨€èªã®çŸ¥è­˜ã‚‚æ‹¡å¼µè¨€èªã®çŸ¥è­˜ã‚‚Cã®çŸ¥è­˜ã‚‚å¿…è¦'))

(('note:Cython has GDB integration to solve this problem'))\n
(('note:Cythonã¯ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«GDBç”¨ã®ä¾¿åˆ©æ©Ÿèƒ½ã‚’æä¾›'))

= Extend language: Cons3\n(('note:æ‹¡å¼µè¨€èªï¼šçŸ­æ‰€2'))

(('tag:center'))
Hard to maintain\n
(('note:(For maintainers, not for users)'))\n
(('note:ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã¯ãªããƒ¡ãƒ³ãƒ†ãƒŠãƒ¼ãŒï¼‰ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãŒå¤§å¤‰'))

  * Base language introduces a new syntax then extend language should implement it\n
    (('note:ãƒ™ãƒ¼ã‚¹ã®è¨€èªãŒæ–°ã—ã„æ§‹æ–‡ã‚’å°å…¥â†’æ‹¡å¼µè¨€èªã§ã‚‚å®Ÿè£…'))

= Not based on C\n(('note:Cè¨€èªä»¥å¤–ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹'))

  * JRuby: Java + Ruby
  * Helix: Rust + Ruby

= How to run: JRuby\n(('note:JRubyã§ã®å‹•ã‹ã—æ–¹'))

  # coderay java
  // Fibonacci.java
  public class Fibonacci {
    public long[] compute(int n) {
      // ...
    }
  }

= How to run: JRuby\n(('note:JRubyã§ã®å‹•ã‹ã—æ–¹'))

  # coderay console
  % javac Fibonacci.java
  % jar cf fibonacci.jar Fibonacci.class

= How to run: JRuby\n(('note:JRubyã§ã®å‹•ã‹ã—æ–¹'))

  # coderay ruby
  require "fibonacci.jar"
  java_import "Fibonacci"
  p Fibonacci.new.compute(100)

= Not based on C: Pros1\n(('note:Cè¨€èªä»¥å¤–ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ï¼šé•·æ‰€1'))

(('tag:center'))
Easier to write than C\n
(('note:Cã‚ˆã‚Šæ›¸ãã‚„ã™ã„'))

  * Simpler syntax\n
    (('note:æ´—ç·´ã•ã‚ŒãŸæ§‹æ–‡'))
  * Rich features compared to C\n
    (('note:Cã‚ˆã‚Šæ©Ÿèƒ½ãŒå¤šã„'))

= Not based on C: Pros2\n(('note:Cè¨€èªä»¥å¤–ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ï¼šé•·æ‰€2'))

(('tag:center'))
Can use libraries\n
in base language\n
(('note:ãƒ™ãƒ¼ã‚¹è¨€èªã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ä½¿ãˆã‚‹'))

  * Major languages have many libs\n
    (('note:åºƒãä½¿ã‚ã‚Œã¦ã„ã‚‹è¨€èªã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚‚å¤šã„'))

= Not based on C: Cons1\n(('note:Cè¨€èªä»¥å¤–ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ï¼šçŸ­æ‰€1'))

(('tag:center'))
Need base language knowledge\n
(('note:ãƒ™ãƒ¼ã‚¹è¨€èªã®çŸ¥è­˜ãŒå¿…è¦'))

  * Java for JRuby(('note:ï¼ˆJRubyãªã‚‰Javaï¼‰'))
  * Rust for Helix(('note:ï¼ˆHelixãªã‚‰Rustï¼‰'))

= Not based on C: Cons2\n(('note:Cè¨€èªä»¥å¤–ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ï¼šçŸ­æ‰€2'))

(('tag:center'))
May need C knowledge\n
(('note:(When Ruby implementation is MRI)'))\n
(('note:Rubyã®å®Ÿè£…ãŒMRIãªã‚‰Cã®çŸ¥è­˜ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œãªã„'))

  * Base language wraps Ruby C API\n
    (('note:ãƒ™ãƒ¼ã‚¹ã®è¨€èªã¯Rubyã®C APIã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã„ã‚‹'))
    * e.g.: (({sys::RSTRING_PTR})) on Helix\n
      (('note:ä¾‹ï¼šHelixãªã‚‰sys::RSTRING_PTRãŒãƒ©ãƒƒãƒ—ã—ãŸAPI'))

= Not based on C: Cons3\n(('note:Cè¨€èªä»¥å¤–ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ï¼šçŸ­æ‰€3'))

(('tag:center'))
Hard to maintain\n
(('note:(When Ruby implementation is MRI)'))\n
(('note:Rubyã®å®Ÿè£…ãŒMRIãªã‚‰ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ãŒå¤§å¤‰ã‹ã‚‚'))

  * Ruby introduces a new API then base language may need to implement it\n
    (('note:RubyãŒæ–°ã—ã„APIã‚’è¿½åŠ â†’ãƒ™ãƒ¼ã‚¹è¨€èªã§ã‚‚å®Ÿè£…ï¼Ÿ'))
    * e.g.: (({rb_gc_adjust_memory_usage()}))

= Provide convenient API\n(('note:ä¾¿åˆ©ãªAPIã‚’æä¾›'))

  * Rice: C++ + Ruby
  * Ext++: C++11 + Ruby
  * Boost.Python: C++ + Python
  * pybind11: C++11 + Python

= How to run: Rice\n(('note:Riceã®å‹•ã‹ã—æ–¹'))

  # coderay cpp

  #include <rice/Class.hpp>

  static const char * // Not VALUE!
  rb_sample_hello(Rice::Object self) {
    return "Hello";
  }
  extern "C" void Init_sample() {
    Rice::define_class("Sample").
      define_method("hello", &rb_sample_hello);
  }

= How to run: Rice\n(('note:Riceã®å‹•ã‹ã—æ–¹'))

  # coderay ruby

  # extconf.rb
  require "mkmf-rice"
  create_makefile("sample")

= How to run: Rice\n(('note:Riceã®å‹•ã‹ã—æ–¹'))

  # coderay console

  % ruby extconf.rb
  % make

= How to run: Rice\n(('note:Riceã®å‹•ã‹ã—æ–¹'))

  # coderay ruby

  require_relative "sample.so"
  p Sample.new.hello
  # => "Hello"

= Provide C++ API: Pros\n(('note:C++ APIã‚’æä¾›ï¼šé•·æ‰€'))

Omit\n
(('note:çœç•¥'))

= Provide C++ API: Cons\n(('note:C++ APIã‚’æä¾›ï¼šçŸ­æ‰€'))

Omit\n
(('note:çœç•¥'))

= Provide C++ API: ConsN\n(('note:C++ APIã‚’æä¾›ï¼šçŸ­æ‰€N'))

(('tag:center'))
Conv from Ruby may be a bother\n
(('note:Rubyå®Ÿè£…ã®ç§»æ¤ãŒé¢å€’'))

  * C++ with convenient Ruby C API needs more code than Ruby\n
    (('note:Rubyã®C APIã«C++ã®ä¾¿åˆ©APIãŒã‚ã£ã¦ã‚‚'))\n
    (('note:Rubyã‚ˆã‚Šã‚‚ãŸãã•ã‚“ã‚³ãƒ¼ãƒ‰ãŒå¿…è¦'))

= From Ruby: Rice\n(('note:Rubyã‹ã‚‰Riceã«ç§»æ¤'))

  # coderay ruby
  def fib(n)
    prev = 1
    current = 1
    1.step(n - 1).collect do
      prev, current = current, current + prev
      prev
    end
  end

= From Ruby: Rice\n(('note:Rubyã‹ã‚‰Riceã«ç§»æ¤'))

  # coderay cpp
  std::vector<uint64_t> fib(Rice::Object self, int n) {
    uint64_t prev = 1, current = 1;
    std::vector<uint64_t> numbers;
    for (int i = 1; i < n; ++i) {
      auto temp = current; current += prev; prev = temp;
      numbers.push_back(prev);
    }
    return numbers;
  }
