= Improve extension API\n(('note:拡張ライブラリーAPIの改良'))

: subtitle
   C++ as better language for extension\n
   (('note:C++で拡張ライブラリーを開発しやすくなる'))
: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2017
: date
   2017-09-18
: allotted-time
   35m
: theme
   .

= Ad1: Silver sponsor

  # img
  # src = images/clear-code-silver-sponsor.png
  # relative_height = 100
  # reflect_ratio = 0.1

== Slide properties

: enable-title-on-image
   false

= Ad2: Red Data Tools

  * Project that provides data processing tools for Ruby\n
    (('note:Ruby用のデータ処理ツール群を提供するプロジェクト'))
    * https://red-data-tools.github.io/
  * Workshop in afternoon break at the 2nd day (today!)\n
    (('note:2日目（今日！）の午後休憩中にワークショップがあるよ！'))

= Ad3: OSS Gate

  * Project that increases people who join OSS development\n
    (('note:OSSの開発に継続的に参加する人を継続的に増やす取り組み'))
    * https://oss-gate.github.io/

= Ad3: OSS Gate

  * Ruby is an OSS\n
    (('note:RubyもOSS'))
    * OSS Gate wants to increase people to join Ruby itself and RubyGems development!\n
      (('note:OSS GateではRuby本体の開発や各種RubyGemの開発に参加する人も増やしたい！'))

= Ad3: OSS Gate

  * Now, works on Tokyo, Sapporo, Osaka and Kyoto\n
    (('note:現在は東京・札幌・大阪・京都で活動中'))
    * If you live at one of them, join "OSS Gate workshop"!\n
      (('note:これらの地域に住んでいる人は「OSS Gateワークショップ」に参加しよう！'))

= Ad3: OSS Gate

  * Wants to work on Hiroshima and other areas all over the world!\n
    (('note:広島や世界中のいろんな地域で活動したい！'))
    * If you're interested in increasing people who join OSS development, talk to me!\n
      (('note:OSSの開発に参加する人が増えることに興味のある人は私に声をかけて！'))

= Abstract\n(('note:概要'))

  * Show some approaches to write extensions\n
    (('note:拡張ライブラリーの書き方をいくつか紹介'))
  * Describe C++ approach deeply\n
    (('note:C++を使った方法の詳細を説明'))
    * Because I recommend the approach!\n
      (('note:C++を使った方法が一番いいと思っているから！'))

= Extension\n(('note:拡張ライブラリー'))

  * Ruby library implemented in C\n
    (('note:Cで実装されたRubyのライブラリー'))
    * Or in other languages such as\n
      C++ and Objective-C\n
      (('note:C++やObjective-Cなど他の言語での実装でもよい'))

= Ruby API

  # coderay ruby

  class Sample
    def hello
      "Hello"
    end
  end

= C API

  # coderay c

  #include <ruby.h>

  static VALUE
  rb_sample_hello(VALUE self)
  {
    return rb_str_new_static("Hello");
  }

  void
  Init_sample(void)
  {
    VALUE sample = rb_define_class("Sample", rb_cObject);
    rb_define_method(sample, "hello", rb_sample_hello, 0);
  }

= C++ API

  # coderay cpp

  #include <ruby.hpp>

  void
  Init_sample(void)
  {
    rb::Class("Sample", rb_cObject).
      define_method("hello",
                    [](VALUE self) {
                      return rb_str_new_static("Hello");
                    });
  }

= Ruby API\nwithout syntax sugar

  # coderay ruby

  Sample = Class.new do
    define_method(:hello) do
      "Hello"
    end
  end

= C++ API (reprise)

  # coderay cpp

  // Similar to Ruby API without syntax sugar!
  rb::Class("Sample", rb_cObject).
    define_method("hello",
                  [](VALUE self) {
                    return rb_str_new_static("Hello");
                  });

= Why is extension needed?

  * Performance
  * Integration with existing libraries implemented in other languages such as C and C++
    * It's called as binding

= Performance

  * Extension is fast
    * Because C/C++ is fast
    * Especially loop

= Loop: Sum

  # coderay ruby

  numbers = (1..100000).to_a
  # Ruby level loop: 25.1ms
  numbers.inject(&:+)
  # C level loop:     0.5ms
  # 50x faster
  numbers.sum

= Target use case

  * Mostly write your script in Ruby
  * Implement only bottle neck as extension

= e.g.: Machine Learning

  * ...

= Writing ext is difficult

  * Require C knowledge
  * Require Ruby C API knowledge
  * Require how to write extension knowledge

Most Rubyists don't have them

= I don't want to learn...

You should learn👐\n
(('note:(if you want more performance)'))

# 🎒
# 🏫

= Easy to write ext

  * Assumptions
    * Ruby knowledge
    * Ruby C API knowledge
  * Improve Ruby C API
    * Ruby C API isn't bad but has some verbosities because of C

= Approaches

  * Extend language
    * Ruby + α syntax
  * Based on not C language
    * There are many better C languages
  * Provide convenient API
    * Enhance C API

= Extend language

  * Rubex: Extended Ruby
  * Cython: Extended Python

= How to run

  * Compile code for extended language to C
  * Build compiled C code
  * Load the built extension

= Extended syntax

  * Type information
  * C code snippet

= How to run: Rubex

  # coderay ruby
  # fibonacci.rubex
  class Fibonacci
    # "int" is type information
    def compute(int n)
      # ...
    end
  end

= How to run: Rubex

  # coderay console
  % rubex fibonacci.rubex
  % cd fibonacci
  % ruby extconf.rb
  % make

= How to run: Rubex

  # coderay ruby
  require_relative "fibonacci.so"
  p Fibonacci.new.compute(100)

= Extend language: Pros

  * Friendly syntax for base language users
  * Easy to migrate from base language
  * Don't require large C knowledge

= Extend language: Cons1

(('tag:center'))
You realize that it's not friendly syntax when you use it

  * Small differences will confuse you

= Extend language: Cons2

(('tag:center'))
Difficult to debug

  * Need base language, extend language and C knowledge

(('note:Cython has GDB integration to solve this problem'))

= Extend language: Cons3

(('tag:center'))
Need many works to maintain\n
(('note:(For authors, not for users)'))

  * Base language introduces a new syntax then extend language should implement it

= Based on not C language

  * JRuby: Java + Ruby
  * Helix: Rust + Ruby
  * crystal_ruby: Crystal + Ruby

= How to run: JRuby

  # coderay java
  // Fibonacci.java
  public class Fibonacci {
    public long[] compute(int n) {
      // ...
    }
  }

= How to run: JRuby

  # coderay console
  % javac Fibonacci.java
  % jar cf fibonacci.jar Fibonacci.class

= How to run: JRuby

  # coderay ruby
  require "fibonacci.jar"
  java_import "Fibonacci"
  p Fibonacci.new.compute(100)

= Based on not C: Pros

  * Easy to write than C
  * Rich features than C
  * Can use libraries in base language

= Based on not C: Cons1

(('tag:center'))
Need base language knowledge

  * Java for JRuby
  * Rust for Helix

= Based on not C: Cons2

(('tag:center'))
May need C knowledge\n
(('note:(When Ruby implementation is MRI)'))

  * Base language wraps Ruby C API
    * e.g.: (({sys::RSTRING_PTR})) on Helix

= Based on not C: Cons3

(('tag:center'))
May need many works to maintain\n
(('note:(When Ruby implementation is MRI)'))

  * Ruby introduces a new API then base language may need to implement it

= Provide convenient API

  * Rice: C++ + Ruby
  * Ext++: C++ + Ruby
  * Boost.Python: C++ + Python
  * pybind11: C++11 + Python

= How to run: Rice

  # coderay cpp

  #include <rice/Class.hpp>

  static const char * // Not VALUE!
  rb_sample_hello(Rice::Object self) {
    return "Hello";
  }

  extern "C" void Init_sample() {
    Rice::define_class("Sample").
      define_method("hello", &rb_sample_hello);
  }

= How to run: Rice

  # coderay ruby

  # extconf.rb
  require "mkmf-rice"
  create_makefile("sample")

= How to run: Rice

  # coderay console

  % ruby extconf.rb
  % make

= How to run: Rice

  # coderay ruby

  require_relative "sample.so"
  p Sample.new.hello
  # => "Hello"

= Provide C++ API: Pros1

(('tag:center'))
Easy to write than C

  * Auto type conversion
  * Auto exception conversion

= Provide C++ API: Pros2

(('tag:center'))
Easy to maintain\n
(('note:(For authors, not for users)'))

  * Can use C directly including macro
  * Don't need wrapper for C API\n
    (('note:(Wrapped API may be useful)'))

= Provide C++ API: Pros3

(('tag:center'))
Easy to debug\n
(('note:if you have C knowledge'))

  * Can use GDB/LLDB directly
    * GDB/LLDB have built-in C++ support

= Provide C++ API: Cons1

(('tag:center'))
Require C and C++ knowledge

  * Many Rubyists don't have

= Provide C++ API: Cons2

(('tag:center'))
Converting from Ruby may be board

  * Ruby provides powerful syntax to users
  * C++ with convenience Ruby C API needs more codes than Ruby

= From Ruby: Ext++

  # coderay ruby
  def fib(n)
    prev = 1
    current = 1
    1.step(n - 1).collect do
      prev, current = current, current + prev
      prev
    end
  end

= From Ruby: Ext++

  # coderay cpp
  std::vector<uint64_t> fib(int n) {
    uint64_t prev = 1
    uint64_t current = 1
    std::vector<uint64_t> numbers;
    for (int i = 1; i < n; ++i) {
      numbers.push_back(current);
      auto temp = current;
      current += prev;
      prev = temp;
    }
    return numbers;
  }

